import os
import matplotlib.pyplot as plt
import numpy   as np
import pyvista as pv

from tqdm   import tqdm
from osgeo  import gdal, osr
from pyproj import CRS, Transformer

import tools.visualizations as vis

class DEM:
    def __init__(self, config):
        if not os.path.exists(config['ELEVATION MODELS']['model_path']):
            # Convert DEM to mesh
            self._dem_2_mesh(config)
        self.mesh   = pv.read(config['ELEVATION MODELS']['model_path'])
        #self.dem    = gdal.Open(config['ELEVATION MODELS']['dem_path']) # Placeholder for DEM data (downloaded from Geonorge)
        #self.points = None # Placeholder for point cloud data (calculated from DEM)

    # Private methods
    def _dem_2_mesh(self, config):
        """
        A function for converting a specified DEM to a 3D mesh model (*.vtk, *.ply or *.stl). Consequently, mesh should be thought of as 2.5D representation.
         - param path_dem:   string     path to dem for reading
         - param model_path: string     path to where 3D mesh model is to be written.
         - return: Nothing
        """
        # Input and output file paths
        pointcloud_path = config['ELEVATION MODELS']['model_path'].split(sep = '.')[0] + '_temp'                                                     #Oliver: output file path for the file model.xyz

        try:
            # Check if the pointcloud "model.xyz" already exists
            if os.path.exists(pointcloud_path):
                print(f"Model file {pointcloud_path} already exists. Skipping conversion.")
                # Load the existing model file
                points = np.loadtxt(pointcloud_path)
            else:
                # Open the input raster dataset
                ds = gdal.Open(config['ELEVATION MODELS']['dem_path'])
        
                if ds is None:
                    print(f"Failed to open {config['ELEVATION MODELS']['dem_path']}")
                else:
                    # Read the first band (band index is 1)
                    band          = ds.GetRasterBand(1)
                    no_data_value = band.GetNoDataValue()
                    if band is None:
                        print(f"Failed to open band 1 of {config['ELEVATION MODELS']['dem_path']}")
                        raise ValueError("Failed to open band 1 of the DEM")
                    else:
                        # Get the geotransform information to calculate coordinates
                        # This step gets the geotransform information from the raster dataset, so that the position of the DEM in the real world can be determined.
                        geotransform = ds.GetGeoTransform()
                        x_origin     = geotransform[0]                                              #The x-coordinate of the upper-left corner of the top-left pixel.
                        y_origin     = geotransform[3]                                              #The y-coordinate of the upper-left corner of the top-left pixel.
                        x_resolution = geotransform[1]                                              #The pixel width in the x-direction.
                        y_resolution = geotransform[5]                                              #The pixel height in the y-direction.
                        # Get the CRS information
                        spatial_reference = osr.SpatialReference(ds.GetProjection())

                        # Get the EPSG code
                        epsg_proj = None
                        if spatial_reference.IsProjected():
                            epsg_proj = spatial_reference.GetAttrValue("AUTHORITY", 1)              #Get the EPSG code
                            geoidHeight = np.float64(config['SETTINGS']['wgs84_altitude_at_takeoff'], fallback=0.0)
                        elif spatial_reference.IsGeographic():
                            epsg_proj = spatial_reference.GetAttrValue("AUTHORITY", 0)
                            geoidHeight = 0

                        print(f"DEM projected EPSG Code: {epsg_proj}")

                        config.set('AUTOGENERATED', 'dem_epsg', str(epsg_proj))
                        with open('CONFIG\\config.ini', 'w') as configfile:
                            config.write(configfile)

                        # Get the band's data as a NumPy array
                        band_data = band.ReadAsArray()

                        # Replace no-data values with 0 (sea surface level)
                        band_data = np.where(band_data == no_data_value, 0, band_data)
#                        vis.visualize_dem(band_data)

                        # Open file in write mode - this will create the file if it doesn't exist, or overwrite it if it does exist
                        print(f"Generating Pointcloud from DEM")
                        with open(pointcloud_path, 'w') as xyz_file:
                            # Write data to the XYZ file using the mask and calculated coordinates
                            for y in tqdm(range(ds.RasterYSize), desc="Processing rows", unit="row"):
                                for x in range(ds.RasterXSize):
                                    x_coord = x_origin + x * x_resolution
                                    y_coord = y_origin + y * y_resolution
                                    xyz_file.write(f"{x_coord} {y_coord} {band_data[y, x]}\n")

                        # Clean up
                        ds   = None
                        band = None
                print("Conversion completed.")
                points = np.loadtxt(pointcloud_path)                                                     #Loads the pointcloud ("model_temp" file) into a numpy array ("model_temp" was created a few lines ago).

            # Add checks for points data
            if points.size == 0:
                raise ValueError("No points loaded from xyz file")

            # Subsample the points to reduce the number of vertices in the mesh (take every nth point)
            subsample_factor  = int(config['ELEVATION MODELS']['subsample_factor'])
            points_subsampled = points[::subsample_factor]
#            vis.visualize_pointcloud(points_subsampled)

            # Create a pyvista point cloud object
            cloud = pv.PolyData(points_subsampled)
            print(f"PolyData created with {cloud.n_points} points")

            # Create 2D mesh from the 3D point cloud.
            print(f"-------------------------------------------------")
            print(f"         Creating mesh from point cloud")
            print(f"-------------------------------------------------")
            self.mesh = cloud.delaunay_2d()
            print(f"Mesh created with {self.mesh.n_cells} cells")
            # Basic mesh validation
            if self.mesh.n_cells == 0:
                raise ValueError("Mesh creation resulted in 0 cells")

        except Exception as e:
            print(f"Error in mesh creation: {str(e)}")
            print(f"Points data statistics:")
            print(f"- Min values: {np.min(points, axis=0)}")
            print(f"- Max values: {np.max(points, axis=0)}")
            print(f"- Number of unique points: {len(np.unique(points, axis=0))}")
            raise

        try:
            epsg_geocsc = config['Coordinate Reference Systems']['epsg_wgs84']      # The EPSG code for the geocentric coordinate system (ECEF)
            epsg_proj   = config['AUTOGENERATED']['dem_epsg']                       # The EPSG code for the Digital Elevation Model (DEM)
            geocsc      = CRS.from_epsg(epsg_geocsc)
            proj_dem    = CRS.from_epsg(epsg_proj)
            transformer = Transformer.from_crs(proj_dem, geocsc)                            # Transform the mesh points to from projected CRS to the to geocentric CRS (ECEF). 

            print(f"Mesh geocentric EPSG Code: {epsg_geocsc}")

            #Projecting mesh from EPSG xyz to EPSG 4326 (WGS84 geocentric/ECEF)
            points_proj = self.mesh.points

            eastUTM  = points_proj[:, 0].reshape((-1, 1))
            northUTM = points_proj[:, 1].reshape((-1, 1))
            heiUTM   = points_proj[:, 2].reshape((-1, 1))

            (xECEF, yECEF, zECEF) = transformer.transform(xx=eastUTM, 
                                                          yy=northUTM, 
                                                          zz=heiUTM + geoidHeight)

            self.mesh.points[:, 0] = xECEF.reshape(-1)
            self.mesh.points[:, 1] = yECEF.reshape(-1)
            self.mesh.points[:, 2] = zECEF.reshape(-1)

            # Save mesh
            model_path = config['ELEVATION MODELS']['model_path']
            self.mesh.save(model_path)

        except Exception as e:
            print(f"Error in mesh transformation: {str(e)}")
            raise
